
<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8>
    <style>
    html, body {width: 100%}
    body {margin: 0px;}
    aside.toc { position:fixed; top:0px; left: 0px; width: 25%; border-right: 2px solid grey; overflow: scroll}
    main { position: relative; width: 72%; left: 25%; margin-left: 25px; }
    </style>
</head>
<body>
<aside class="toc"><div class="toc">
<ul>
<li><a href="#hi221hi221gw-user-guide">HI221/HI221GW User Guide</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#features">Features</a><ul>
<li><a href="#on-board-sensors">On-board sensors</a></li>
<li><a href="#data-process">Data process</a></li>
<li><a href="#communication-interface-and-power-supply-of-hi221">Communication interface and power supply of HI221</a></li>
<li><a href="#others">Others</a></li>
</ul>
</li>
<li><a href="#hardware-specifications-nodes">Hardware Specifications (nodes)</a></li>
<li><a href="#hardware-installation">Hardware Installation</a></li>
<li><a href="#hardware-performance">Hardware Performance</a><ul>
<li><a href="#output-accuracy-of-attitude">Output accuracy of attitude</a></li>
<li><a href="#gyroscope">Gyroscope</a></li>
<li><a href="#accelerometer">Accelerometer</a></li>
<li><a href="#magnetometer">Magnetometer</a></li>
<li><a href="#data-interface-specifications-uart">Data interface specifications (UART)</a></li>
<li><a href="#data-interface-specifications-24g-rf">Data interface specifications (2.4G RF)</a></li>
</ul>
</li>
<li><a href="#definition-of-reference-frame">Definition of Reference Frame</a></li>
<li><a href="#protocol-of-serial-communication">Protocol of Serial Communication</a><ul>
<li><a href="#format-of-a-packet">Format of a Packet</a></li>
<li><a href="#factory-default-register">Factory Default Register</a></li>
<li><a href="#example-of-data-structure-in-a-frame">Example of Data Structure in a Frame</a></li>
</ul>
</li>
<li><a href="#general-at-command">General AT Command</a><ul>
<li><a href="#atid">AT+ID</a></li>
<li><a href="#atgwid">AT+GWID</a></li>
<li><a href="#aturfr">AT+URFR</a></li>
<li><a href="#atinfo">AT+INFO</a></li>
<li><a href="#atodr">AT+ODR</a></li>
<li><a href="#atbaud">AT+BAUD</a></li>
<li><a href="#ateout">AT+EOUT</a></li>
<li><a href="#atrst">AT+RST</a></li>
<li><a href="#attrg">AT+TRG</a></li>
<li><a href="#atsetpel">AT+SETPEL</a></li>
<li><a href="#atmode">AT+MODE</a></li>
</ul>
</li>
<li><a href="#appendix-b-conversion-between-quaternion-and-euler-angles">Appendix B - Conversion Between Quaternion and Euler Angles</a><ul>
<li><a href="#basic-conceptions-of-quaternion">Basic conceptions of quaternion</a></li>
<li><a href="#conversion-between-quaternions-rotation-matrices-and-euler-angles">Conversion between quaternions, rotation matrices, and Euler angles</a><ul>
<li><a href="#quaternion-rotation-matrix">Quaternion -&gt; Rotation matrix</a></li>
<li><a href="#quaternion-euler-angles">Quaternion -&gt; Euler angles</a></li>
<li><a href="#euler-angles-quaternion">Euler angles -&gt; Quaternion</a></li>
<li><a href="#euler-angles-rotation-matrix-n-b">Euler angles -&gt; Rotation matrix (n-&gt;b)</a></li>
<li><a href="#rotation-matrix-n-b-euler-angles">Rotation matrix (n-&gt;b) -&gt; Euler angles</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix-c-firmware-upgrade-and-factory-reset">Appendix C - Firmware Upgrade and Factory Reset</a></li>
</ul>
</li>
</ul>
</div>
</aside>
<main><h1 id="hi221hi221gw-user-guide">HI221/HI221GW User Guide</h1>
<p><p style="text-align: right;">HI221 wireless IMU and receiver system, Rev 0.2</p>
<p><img alt="" src="figures/front_image.png"></p>
<div style="page-break-after: always;"></div>

<div class="toc">
<ul>
<li><a href="#hi221hi221gw-user-guide">HI221/HI221GW User Guide</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#features">Features</a><ul>
<li><a href="#on-board-sensors">On-board sensors</a></li>
<li><a href="#data-process">Data process</a></li>
<li><a href="#communication-interface-and-power-supply-of-hi221">Communication interface and power supply of HI221</a></li>
<li><a href="#others">Others</a></li>
</ul>
</li>
<li><a href="#hardware-specifications-nodes">Hardware Specifications (nodes)</a></li>
<li><a href="#hardware-installation">Hardware Installation</a></li>
<li><a href="#hardware-performance">Hardware Performance</a><ul>
<li><a href="#output-accuracy-of-attitude">Output accuracy of attitude</a></li>
<li><a href="#gyroscope">Gyroscope</a></li>
<li><a href="#accelerometer">Accelerometer</a></li>
<li><a href="#magnetometer">Magnetometer</a></li>
<li><a href="#data-interface-specifications-uart">Data interface specifications (UART)</a></li>
<li><a href="#data-interface-specifications-24g-rf">Data interface specifications (2.4G RF)</a></li>
</ul>
</li>
<li><a href="#definition-of-reference-frame">Definition of Reference Frame</a></li>
<li><a href="#protocol-of-serial-communication">Protocol of Serial Communication</a><ul>
<li><a href="#format-of-a-packet">Format of a Packet</a></li>
<li><a href="#factory-default-register">Factory Default Register</a></li>
<li><a href="#example-of-data-structure-in-a-frame">Example of Data Structure in a Frame</a></li>
</ul>
</li>
<li><a href="#general-at-command">General AT Command</a><ul>
<li><a href="#atid">AT+ID</a></li>
<li><a href="#atgwid">AT+GWID</a></li>
<li><a href="#aturfr">AT+URFR</a></li>
<li><a href="#atinfo">AT+INFO</a></li>
<li><a href="#atodr">AT+ODR</a></li>
<li><a href="#atbaud">AT+BAUD</a></li>
<li><a href="#ateout">AT+EOUT</a></li>
<li><a href="#atrst">AT+RST</a></li>
<li><a href="#attrg">AT+TRG</a></li>
<li><a href="#atsetpel">AT+SETPEL</a></li>
<li><a href="#atmode">AT+MODE</a></li>
</ul>
</li>
<li><a href="#appendix-b-conversion-between-quaternion-and-euler-angles">Appendix B - Conversion Between Quaternion and Euler Angles</a><ul>
<li><a href="#basic-conceptions-of-quaternion">Basic conceptions of quaternion</a></li>
<li><a href="#conversion-between-quaternions-rotation-matrices-and-euler-angles">Conversion between quaternions, rotation matrices, and Euler angles</a><ul>
<li><a href="#quaternion-rotation-matrix">Quaternion -&gt; Rotation matrix</a></li>
<li><a href="#quaternion-euler-angles">Quaternion -&gt; Euler angles</a></li>
<li><a href="#euler-angles-quaternion">Euler angles -&gt; Quaternion</a></li>
<li><a href="#euler-angles-rotation-matrix-n-b">Euler angles -&gt; Rotation matrix (n-&gt;b)</a></li>
<li><a href="#rotation-matrix-n-b-euler-angles">Rotation matrix (n-&gt;b) -&gt; Euler angles</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix-c-firmware-upgrade-and-factory-reset">Appendix C - Firmware Upgrade and Factory Reset</a></li>
</ul>
</li>
</ul>
</div>
<div style="page-break-after: always;"></div>

<h2 id="introduction">Introduction</h2>
<p>H221/HI221GW is a miniature wireless inertial measurement unit (IMU) system launched by HIPNUC electronic company. This unit features low cost, high performance, small size, and low latency. It can output 3-dimensional azimuth data which is calibrated by local geographic coordinates. The data are processed by our fusion algorithm, including roll angle, pitch angle, and relative heading angle. It can also output raw sensor data. 
H221/HI221GW system consists of HI221GW (receiver) and HI221 (attitude module). A HI221GW can connect up to 8 HI221 modules to form a star network structure. Each HI221 can output attitude data real-time, and the output rate can reach 100Hz.</p>
<p><img alt="" src="figures/start_network.png"></p>
<h2 id="features">Features</h2>
<h3 id="on-board-sensors">On-board sensors</h3>
<ul>
<li>Three-axis gyroscope with </li>
<li>maximum range: Â± 2000 Â°/s</li>
<li>output rate up to 2000Hz</li>
<li>Three-axis accelerometer with</li>
<li>maximum range: Â± 8g</li>
<li>output rate up to 125Hz</li>
<li>Triaxial geomagnetic field sensor with </li>
<li>maximum range: 800mG</li>
<li>internal sampling rate up to 100Hz</li>
</ul>
<h3 id="data-process">Data process</h3>
<ul>
<li>Accelerometers are calibrated before they go out.</li>
<li>Quaternions and Euler angles are calculated in geographic coordinate system by data fusion algorithm.</li>
</ul>
<h3 id="communication-interface-and-power-supply-of-hi221">Communication interface and power supply of HI221</h3>
<ul>
<li>Serial port (compatible with TTL, which can be directly connected with 5V or 3.3V serial port device)</li>
<li>Supply voltage: 3.3 (+/- 100 mV)</li>
<li>Power consumption at peakï¼120mA (While using RF and Tx emitting)</li>
</ul>
<h3 id="others">Others</h3>
<ul>
<li>We provide program with GUI on the PC side, featuring real-time data display, waveform, calibration and excel data recording functions.</li>
<li>Multiple configurable module parameters for user to apply.</li>
</ul>
<h2 id="hardware-specifications-nodes">Hardware Specifications (nodes)</h2>
<p>| Parameter                    | Description                                                  |
| ---------------------------- | ------------------------------------------------------------ |
| Output Interface             | UART(TTL 1.8V - 3.3V) or 2.4RF Radio                         |
| Supply Voltage               | 3.3V (Â± 100mV)                                               |
| Power Consumption            | 396mW @3.3V                                                  |
| Temperature Tolerance        | -20  - 85                                                  |
| Maximum Linear Accelerations | 0 - 115 $m/s^2$                                              |
| Size                         | 20 x 38 x 8.5mm (W x L x H)                                  |
| On-board Sensors             | 3-axis gyroscope, 3-axis accelerometer and 3-axis magnetometer |</p>
<h2 id="hardware-installation">Hardware Installation</h2>
<p>Due to the sensor manufacturing process, the performance of the X/Y and Z axes is slightly different. It is recommended that :</p>
<ul>
<li>Make the module's Z axis parallel the direction of gravity in your installation. In other words, install the module horizontally. </li>
<li>Keep the module at least 10cm away from magnetic components such as iron housings and low-power motors.</li>
</ul>
<h2 id="hardware-performance">Hardware Performance</h2>
<h3 id="output-accuracy-of-attitude">Output accuracy of attitude</h3>
<p>| Attitude                                              | Type | Maximum |
| ----------------------------------------------------- | ---- | ------- |
| Roll Angle \ Pitch Angle - Error at static situation  | 0.2Â° | 0.4Â°    |
| Roll Angle \ Pitch Angle - Error at dynamic situation | 0.5Â° | 2.0Â°    |
| Heading Angle                                         | -    | -       |</p>
<h3 id="gyroscope">Gyroscope</h3>
<p>| Parameter       | Value                               |
| --------------- | ----------------------------------- |
| Measuring Range | Â±2000Â°/s                            |
| Non-linearity   | Â±0.1% (Has best performance at 25Â°) |
| Noise density   | 0.08Â°/s/$ \sqrt{Hz}$                |
| Sampling Rate   | 2000Hz                              |</p>
<h3 id="accelerometer">Accelerometer</h3>
<p>| Parameter           | Value                                    |
| ------------------- | ---------------------------------------- |
| Measuring Range     | Â±8G (1G = 1x Gravitational acceleration) |
| Non-linearity       | Â±0.5% (Has best performance at 25Â°)      |
| Maximum zero offset | 10mG (Calibrated)                        |
| Noise density       | 250 $ uG\sqrt{Hz}$                       |
| Sampling Rate       | 125Hz                                    |</p>
<h3 id="magnetometer">Magnetometer</h3>
<p>| Parameter       | Value   |
| --------------- | ------- |
| Measuring Range | Â±8Gauss |
| Non-linearity   | Â±0.1%   |
| Sampling Rate   | 100Hz   |</p>
<h3 id="data-interface-specifications-uart">Data interface specifications (UART)</h3>
<p>| Parameter               | Value                              |
| ----------------------- | ---------------------------------- |
| Serial Output Baud Rate | 4800/9600/115200/460800 (Optional) |
| Output Frame Rate       | 1 - 400Hz                          |</p>
<h3 id="data-interface-specifications-24g-rf">Data interface specifications (2.4G RF)</h3>
<p>| Parameters                          | Value |
| ----------------------------------- | ----- |
| In Air Baud Rate                    | 1Mbps |
| Output Frame Rate                   | 100Hz |
| Maximum Number of Connected Devices | 8     |</p>
<h2 id="definition-of-reference-frame">Definition of Reference Frame</h2>
<p>This product uses <strong>right-hand</strong> (cartesian) coordinate system. The output of quaternions and Euler angles are the rotation from the sensor coordinate system to the inertial coordinate system (which is also called world coordinate system). </p>
<p>The rotation order of Euler angles  is ZYX (Z axis first, then Y axis, and finally X axis), which is specifically defined as follows :</p>
<ul>
<li>Rotate around Z axis : Yaw, phi ($\psi$) . The range is -180Â° to 180Â°</li>
<li>Rotate around Y axis : Pitch, theta ($\theta$) . The range is -90Â° to 90Â°</li>
<li>Rotate around X axis : Roll, psi ($\phi$) . The range is -180Â° to 180Â°</li>
</ul>
<p>This product uses (North-West-Up, NWU) coordinate system, which is defined as followsï¼</p>
<ul>
<li>Positive X axis points to north</li>
<li>Positive Y axis points to west</li>
<li>Positive Z axis points to the sky</li>
</ul>
<p>When using the NWU system and the module is simulated as an aircraft, the X axis should be considered as heading direction. When the coordinate system of sensor and world are coincide, the ideal output of the Euler angles should be : </p>
<ul>
<li>Pitch = 0 Â°, Roll = 0 Â°, Yaw = 0 Â°</li>
</ul>
<h2 id="protocol-of-serial-communication">Protocol of Serial Communication</h2>
<h3 id="format-of-a-packet">Format of a Packet</h3>
<p>For more applications, we provide data analysis functions by C and C# in supporting resources. After the module is powered on, the packets output rate is set by default at 100Hz (factory default output rate). The format of data packet is described as follows :</p>
<p>|Field | Syncing frame header | Frame type | Frame length | CRC16 | Data in a frame |
|------------ | -------------|------------ |------------ |------------ |------------ |
|name | PRE | TYPE | LEN | CRC | REG_ADDR(N) + DATA(N) |
|size (byte) | 0 | 1 | 2 | 2 | variable (1-64) |
|shift (byte) | 0 | 1 | 2 | 4 | 6 |
|value (hex) | 0x5A | 0xA5 | length value | CRC check code | check more details in the next section |
|type | uint8_t | uint8_t | uint16_t | uint16_t | - |</p>
<ul>
<li>
<p>PRE
    It's fixed at 0x5A.</p>
</li>
<li>
<p>TYPE
    It's fixed at 0xA5 representing a data frame.</p>
</li>
<li>
<p>LEN 
    The length of data field in a data frame. The maximum of a data frame is 256 bytes LSB (low byte first), and the length only includes of the real data, not including <code>PRE</code>,<code>TYPE</code>,<code>LEN</code>,<code>CRC</code> numeric field.</p>
</li>
<li>
<p>CRC
    16-bit CRC checksum of all the other data and LSB[^LSB] in a frame, except the CRC itself. CRC implementing functions is presented as followsï¼</p>
</li>
</ul>
<p><code>/*
    currectCrc: previous crc value, set 0 if it's first section
    src: source stream data
    lengthInBytes: length
*/
static void crc16_update(uint16_t *currectCrc, const uint8_t *src, uint32_t lengthInBytes)
{
    uint32_t crc = *currectCrc;
    uint32_t j;
    for (j=0; j &lt; lengthInBytes; ++j)
    {
        uint32_t i;
        uint32_t byte = src[j];
        crc ^= byte &lt;&lt; 8;
        for (i = 0; i &lt; 8; ++i)
        {
            uint32_t temp = crc &lt;&lt; 1;
            if (crc &amp; 0x8000)
            {
                temp ^= 0x1021;
            }
            crc = temp;
        }
    } 
    *currectCrc = crc;
}</code></p>
<ul>
<li>REG_ADDR and DATA
    A frame of data can be composed of multiple data packets. Each data packet contains two parts: register address (REG_ADDR) and register data (DATA). The register address determines the type and length of the data, and DATA is the content of register data. Supported list of registers in the module is described as follows :</li>
</ul>
<p>| Register address | Bytes in register | Name          | Unit    |
| -------- | ---------- | ----------------- | ---------- |
| 0x90 | 1 | user ID of the module | N/A |
| 0xA0     | 6          | acceleration | 0.001G[^G]  |
| 0xA5 | 6 | linear acceleration | 0.001G |
| 0xB0     | 6          | angular velocity | 0.1Â°/s     |
| 0xC0     | 6          | strength of magnetic field | 0.001Gauss |
| 0xD0     | 6          | Euler angles (as integer) | 1Â° |
| 0xD9     | 12         | Euler angles (as float/double) | 1Â° |
| 0xD1     | 16         | quaternion   | N/A      |
| 0xF0 | 4 | air pressure | Pa |
| 0x71 | 128-256 bytes (variable) | Quaternion collection from wireless nodes | N/A |
| 0x72 | 48-96 bytes (variable) | Euler angles collection from wireless nodes | 1Â° |
| 0x75 | 48-96 bytes (variable) | acceleration collection from wireless nodes | 0.001G[^G] |
| 0x78 | 48-96 bytes (variable) | angular velocity collection of wireless nodes | 0.1Â°/s |
| 0x61 | 3 | extensive identification of the wireless data frame | N/A |</p>
<p>[^G]: 1G = 1x (Local gravitational acceleration)</p>
<ul>
<li>0x90 
    user ID of the module</li>
<li>0xA0
    Raw acceleration of the sensor, outputted as int16, and three axes in total. Each axis occupies 2 bytes, so the total of X, Y, Z axes is 6 bytes, and LSB.</li>
<li>0xA5
    Linear acceleration value without gravity in geographic coordinate system, outputted as int16. There are 3 axes, X, Y, and Z, each axis occupies 2 bytes, so the total is 6 bytes, and LSB.</li>
<li>0xB0
    Angular velocity of the sensor, outputted as int16. There are 3 numbers for 3 axes, X, Y, and Z, and each number occupies 2 bytes, so the total of them is 6 bytes, LSB.</li>
<li>0xC0
    The strength of magnetic field measured by the sensor, outputted as int16. There are numbers in 3 axes, X, Y, and Z, and each number occupies 2 bytes, so the total is 6 bytes, LSB.</li>
<li>0xD0
    Euler angles of the sensor, outputted as int16. There are 3 numbers, , and the order is Pitch-Roll-Yaw for 3 axes, X, Y, and Z, . Each number occupies 2 bytes, LSB. The values of Roll and Pitch you received need to be divided by 100 , and Yaw needs to be divided by 10 to get the true anglesï¼<ul>
<li>ex. When you receive Yaw = 100, the heading angle is 10 Â°.</li>
</ul>
</li>
<li>0xD9
    Euler angles of the sensor, outputted as float. There are 3 numbers, Pitch, Roll and Yaw for 3 axes, X, Y, and Z. Each number occupies 4 bytes (float), LSB.</li>
<li>
<p>0XD1
    Quaternion of the sensor, outputted as float. The data contains four number, which is put in order of W-X-Y-Z. Each of the number occupies 4 bytes (float), so the total size of quaternion is 16 bytes, and LSB.</p>
</li>
<li>
<p>0XF0
    Air pressure. Only works for products with pressure sensor.</p>
</li>
<li>
<p>0x71
    <strong>Only support HI221GW(receiver)</strong>. The collection of quaternions from wireless nodes. A frame consists of a series of quaternions from the nodes, in order of the <strong>user ID</strong> you set. For example, you set nodes ID from 0 to 5, there will be 6 nodes totally. Each node occupies 16 bytes , and consists of a quaternion that is W, X, Y, and Z. Every value is stored in the float type, and each float occupies 4 bytes, and LSB.</p>
</li>
<li>
<p>0x72
    <strong>Only support HI221GW(receiver)</strong>. The collection of Euler angles of wireless nodes. A frame consists of a series of Euler angles from the nodes, in order of the <strong>user ID</strong> you set. For example, you set nodes ID from 0 to 5, there will be 6 nodes totally. Each node occupies 6 bytes, and consists of 3 integers(int16)  in order of Pitch-Roll-Yaw, and each integer occupies 2 bytes, and LSB. The values of Roll and Pitch you received need to be divided by 100 , and Yaw needs to be divided by 10 to get the true anglesï¼</p>
<ul>
<li>ex. When you receive Yaw = 100, the heading angle is 10 Â°.</li>
</ul>
</li>
<li>
<p>0x75
    <strong>Only support HI221GW(receiver)</strong>. The collection of accelerations from wireless nodes. This section consists of a series of accelerations from the nodes, in order of the <strong>user ID</strong> you set. Each node contains 3 <strong>int16_t</strong>, in order of X, Y, and Z. Note that an <strong>int16_t</strong> occupies 2bytes, and LSB.</p>
</li>
<li>
<p>0x78
    <strong>Only support HI221GW(receiver)</strong>. The collection of angular velocities from wireless nodes . This section consists of a series of angular velocities from the nodes, in order of the <strong>user ID</strong> you set. Each node contains 3 <strong>int16_t</strong>, in order of X, Y, and Z. Note that an <strong>int16_t</strong> occupies 2bytes, and LSB.</p>
</li>
<li>
<p>0x61</p>
</li>
</ul>
<p><strong>Only support HI221GW(receiver)</strong>. Get extensive identification of the wireless data frame, 3 bytes in total.</p>
<p>| Bytes offset in data frame extension identification | Value | Description                                       |
  | --------------------------------------------------- | ----- | ------------------------------------------------- |
  | 0                                                   | -     | N/A                                               |
  | 1                                                   | GWID  | GWID of a receiver                                |
  | 2                                                   | CNT   | the count of nodes contained in this frame : 1-16 |</p>
<h3 id="factory-default-register">Factory Default Register</h3>
<p>The register data carried in one frame by factory default is defined as follows :</p>
<p>HI226/HI229:</p>
<p>| Order | Data packet | Description                |
| ----- | ----------- | -------------------------- |
| 1     | 0x90        | user ID of module          |
| 2     | 0xA0        | accelerations              |
| 3     | 0xB0        | angular velocities         |
| 4     | 0xC0        | strength of magnetic field |
| 5     | 0xD0        | Euler angles as integer    |
| 6     | 0xF0        | air pressure               |</p>
<p>HI221GW(wireless receiver of nodes):</p>
<p>| Order | in Register | Description        |
| ----- | ----------- | ------------------ |
| 1     | 0x71        | quaternions        |
| 2     | 0x75        | angular velocities |</p>
<h3 id="example-of-data-structure-in-a-frame">Example of Data Structure in a Frame</h3>
<p>Let's assume that <code>A0, B0, D0</code> are in a frame of some output data . Use the serial assistant to sample a frame of data, and find the following value :</p>
<p><code>5A</code> <code>A5</code> <code>15</code> <code>00</code> <code>A9</code> <code>8B</code> <code>A0</code> <code>EA</code> <code>FF</code> <code>D0</code> <code>03</code> <code>45</code> <code>FF</code> <code>B0</code> <code>00</code> <code>00</code> <code>00</code> <code>00</code> <code>00</code> <code>00</code> <code>D0</code> <code>87</code> <code>00</code> <code>6F</code> <code>27</code>  <code>F5</code> <code>FF</code> </p>
<p>whereï¼</p>
<p><code>5A</code> <code>A5</code> is frame header.</p>
<p><code>15</code> <code>00</code> is the length of data field : (0x00&lt;&lt;8) + 0x15 = 21</p>
<p><code>A9</code> <code>8B</code> is the checksum of CRC : (0x8B&lt;&lt;8) + 0xA9 = 0x8BA9</p>
<ul>
<li><code>A0</code> <code>EA</code> <code>FF</code> <code>D0</code> <code>03</code> <code>45</code> <code>FF</code> are the accelerations, <code>A0</code> is the register address of accelerations. Therefore, the linear accelerations of 3 axes areï¼</li>
</ul>
<p>AccX = (int16_t)((0xFF&lt;&lt;8)+ 0xEA) = -22
  AccY = (int16_t)((0x03&lt;&lt;8)+ 0xD0) = 976
  AccZ = (int16_t)((0xFF&lt;&lt;8)+ 0x45) = -187</p>
<ul>
<li>
<p><code>B0</code> <code>00</code> <code>00</code> <code>00</code> <code>00</code> <code>00</code> <code>00</code> are angular velocities, <code>B0</code> is the register address of angular velocities. From these values, we find that angular velocities around 3 axes are all zero.</p>
</li>
<li>
<p><code>D0</code> <code>87</code> <code>00</code> <code>6F</code> <code>27</code> <code>F5</code> <code>FF</code> are Euler angles, <code>D0</code> is the register address of Euler angles. From these values, we find that :</p>
</li>
</ul>
<p>Pitch= (int16_t)((0x00&lt;&lt;8)+ 0x87) / 100 = 1.35Â° 
  Roll= (int16_t)((0x27&lt;&lt;8)+ 0x6F) / 100 = 100.95Â°
  Yaw = (int16_t)((0xFF&lt;&lt;8)+ 0xF5) / 10 = -1.1Â°</p>
<ul>
<li>
<p>Calculate the CRC ï¼
  Remember that the frame of data is received and stored in the buffer of C language <strong>uint8_t</strong> array : </p>
<p>```
uint16_t payload_len;
uint16_t crc;</p>
<p>crc = 0;
payload_len = buf[2] + (buf[3] &lt;&lt; 8);</p>
<p>/<em> calulate 5A A5 and LEN filed crc </em>/
crc16_update(&amp;crc, buf, 4);</p>
<p>/<em> calulate payload crc </em>/
crc16_update(&amp;crc, buf + 6, payload_len);
```</p>
<p>After calculating, the CRC checksum is 0x8BA9, same as the CRC value carried in the frame. The check result is correct</p>
</li>
</ul>
<h2 id="general-at-command">General AT Command</h2>
<p>The Module parameters can be configured and checked by AT commands. AT commands always start with the ASCII code <code>AT</code>, followed by the control characters, and end with a carriage return and linefeed <code>\r\n</code>. You can use any serial debugging assistant for testing.</p>
<p><img alt="" src="common_figures/at_cmd.png"></p>
<p>General AT Commands :</p>
<p>| Command | Function                    | Configure once (N) / Configure permanent after restart (Y) |
| --------- | ------------------------------ | ----------------------------------------------- |
| AT+ID     | Set a user ID for the module | Y                                               |
| AT+GWID   | Assign an ID to the wireless network domain  (for wireless product) | Y                                               |
| AT+URFR   | Rotate the coordinate system of the module | Y                                               |
| AT+INFO   | Print out the information of module | N                                               |
| AT+ODR    | Set the output frequency for a frame of module data | Y                                               |
| AT+BAUD   | Set Baud for serial port | Y                                               |
| AT+EOUT   | A switch for the output data | N                                               |
| AT+RST    | Reset the module      | N                                               |
| AT+TRG    | Trigger the module to output a frame | N                                               |
| AT+SETPEL | Configure the content in a frame | Y                                               |
| AT+MODE   | Set an operation mode of the module | Y                                               |</p>
<h5 id="atid">AT+ID</h5>
<p>Set a user ID for the module</p>
<p>ex. <code>AT+ID=1</code></p>
<h5 id="atgwid">AT+GWID</h5>
<p>Only support HI221. HI221GW (receiver) and HI221 (node) have GWID attribute, you can assign a number of GWID for specific radio frequency by AT+GWID command, and only when both node and the receiver are in the same GWID, they can communicate with each other. GWID is just like a wireless network domain. If you're using more than one receiver to establish multiple star networks, you have to assign different GWID to each receiver</p>
<p>ex. set GWID=3 for a receiver, meanwhile there are three nodes are individually set to 0,1, and 2. Let them be able to communicate with the receiver.</p>
<p>Command for</p>
<p>receiverï¼<code>AT+GWID=3</code></p>
<p>node 0ï¼ <code>AT+GWID=3</code>  <code>AT+ID=0</code></p>
<p>node 1ï¼ <code>AT+GWID=3</code>  <code>AT+ID=1</code></p>
<p>node 2ï¼ <code>AT+GWID=3</code>  <code>AT+ID=2</code></p>
<h5 id="aturfr">AT+URFR</h5>
<p>In some cases the IMU sensor needs to be installed tilted or vertically. This command helps you to rotate the coordinate system of the sensorï¼</p>
<p>ex.<code>AT+URFR=C00,C01,C02,C10,C11,C12,C20,C21,C22</code> </p>
<p>where
$$
\C_{nn}
$$
support float and double type.
$$
\left{\begin{array}{l}{X} \ {Y} \ {Z}\end{array}\right}<em>{U}=\left[\begin{array}{lll}{C 00} &amp; {C 01} &amp; {C 02} \ {C 10} &amp; {C 11} &amp; {C 12} \ {C 20} &amp; {C 21} &amp; {C 22}\end{array}\right] \cdot\left{\begin{array}{l}{X} \ {Y} \ {Z}\end{array}\right}</em>{B}
$$
where
$$
\left{\begin{array}{l}{X} \ {Y} \ {Z}\end{array}\right}<em>{U}
$$
are the measurement data after coordinate system correction, and
$$
\left{\begin{array}{l}{X} \ {Y} \ {Z}\end{array}\right}</em>{B}
$$
are the measurement data before coordinate system calibration.</p>
<p>Some examples of commandsï¼</p>
<ul>
<li>
<p>Rotate NÂ° around original X or Y or Z axis as a new coordinate system</p>
<ul>
<li>90Â° around original X axis : <code>AT+URFR=1,0,0,0,0,1,0,-1,0</code></li>
<li>-90Â° around original X axis : <code>AT+URFR=1,0,0,0,0,-1,0,1,0</code></li>
<li>180Â° around original X axis : <code>AT+URFR=1,0,0,0,-1,0,0,0,-1</code></li>
<li>90Â° around original Y axis : <code>AT+URFR= 0,0,-1,0,1,0,1,0,0</code></li>
<li>-90Â° around original Y axis : <code>AT+URFR= 0,0,1,0,1,0,-1,0,0</code></li>
<li>180Â° around original Y axis : <code>AT+URFR= -1,0,0,0,1,0,0,0,-1</code></li>
</ul>
</li>
<li>
<p>Factory resetï¼<code>AT+URFR=1,0,0,0,1,0,0,0,1</code></p>
</li>
</ul>
<h5 id="atinfo">AT+INFO</h5>
<p>Print the module information, including model, version, firmware and release date, etc. There are secondary instructions for AT + INFO to achieve more information.</p>
<p>| INFO secondary instruction | Function                                             | Example     |
| -------------------------- | ---------------------------------------------------- | ----------- |
| CAL                        | Print internal calibration parameters of the module. | AT+INFO=CAL |
| RF                         | Print parameters of the wireless product.            | AT+INFO=RF  |
| VER                        | Print details of the firmware version                | AT+INFO=VER |</p>
<h5 id="atodr">AT+ODR</h5>
<p>Set the serial output rate of the module. It can be stored when the power off, and takes effect after restarting the module.</p>
<p>ex. set the rate to 100Hz:  <code>AT+ODR=100</code> </p>
<h5 id="atbaud">AT+BAUD</h5>
<p>Set Baud only in these optionsï¼4800/9600/115200/256000/460800`</p>
<p>ex.  <code>AT+BAUD=115200</code></p>
<p>!!! Notice</p>
<ul>
<li>Beware that wrong Baud will result in failure of communication with the module.</li>
<li>The receiver and module must be in the same Baud.</li>
<li>Baud must be set to 115200 before you updating the firmware.</li>
</ul>
<h5 id="ateout">AT+EOUT</h5>
<p>A switch of the output from module.</p>
<p>ex. </p>
<ul>
<li>Open the serial port of module : <code>AT+EOUT=1</code>  </li>
<li>Close the serial port of module : <code>AT+EOUT=0</code></li>
</ul>
<h5 id="atrst">AT+RST</h5>
<p>Reset the module.</p>
<p>ex. <code>AT+RST</code></p>
<h5 id="attrg">AT+TRG</h5>
<p>Trigger the module to output a frame. It can cooperate with AT + ODR = 0 to trigger a single output</p>
<p>ex. <code>AT+TRG</code></p>
<h5 id="atsetpel">AT+SETPEL</h5>
<p>Set the output protocol:</p>
<p>The content in a frame of data can be configured using AT commands, by following the format:
<code>AT+SETPTL=&lt;ITEM_ID&gt;,&lt;ITEM_ID&gt;...</code>
A frame of data can contain up to 8 packets.</p>
<p>ex. Configure the module to output acceleration, angular velocity, Euler angle and quaternion in the format ï¼<code>AT+SETPTL=A0,B1,D0,D1</code></p>
<p><img alt="" src="common_figures/at_setptl.png"></p>
<h5 id="atmode">AT+MODE</h5>
<p>Set the operation mode for the module.</p>
<p>ex. </p>
<ul>
<li>Set the module to work in 6-axis mode (without magnetic calibration) <code>AT+MODE=0</code></li>
<li>Set the module to work in 9-axis mode (will calibrate the heading angle by geomagnetic field sensor) <code>AT+MODE=1</code></li>
</ul>
<h2 id="appendix-b-conversion-between-quaternion-and-euler-angles">Appendix B - Conversion Between Quaternion and Euler Angles</h2>
<h3 id="basic-conceptions-of-quaternion">Basic conceptions of quaternion</h3>
<p>Quaternion is a number system that extends the complex numbers, representing a point in four-dimensional spaceï¼$q \in \mathbb{R}^{4}=\mathbb{H}$</p>
<p>This table shows several representation of quaternionsï¼</p>
<p>| in complex numbers                                           | in vector                                                    | representation 1                            | representation 2                            |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------- | ------------------------------------------- |
| $q=q_{0}+\mathrm{i} q_{1}+\mathrm{j} q_{2}+\mathrm{k} q_{3}$ | $q=\left[q_{0}, \mathbf{q}\right]=\left[q_{0},\left(\begin{array}{l}{q_{1}} \ {q_{2}} \ {q_{3}}\end{array}\right)\right]$ | $q=\left[q_{0}, q_{1}, q_{2}, q_{3}\right]$ | $q=\left[q_{w}, q_{x}, q_{y}, q_{z}\right]$ |</p>
<p>How to multiplicate basis elementsï¼</p>
<p>$$
\mathrm{i}^{2}=\mathrm{j}^{2}=\mathrm{k}^{2}=\mathrm{ijk}=-1
$$</p>
<p>$$
\mathrm{ij}=\mathrm{k}=-\mathrm{ji}, \quad \mathrm{jk}=\mathrm{i}=-\mathrm{kj}, \quad \mathrm{ki}=\mathrm{j}=-\mathrm{ik}
$$</p>
<p>How to multiplicate two quaternionsï¼</p>
<p>$$
\mathbf{p} \otimes \mathbf{q}=\left[\begin{array}{l}{p_{w} q_{w}-p_{x} q_{x}-p_{y} q_{y}-p_{z} q_{z}} \ {p_{w} q_{x}+p_{x} q_{w}+p_{y} q_{z}-p_{z} q_{y}} \ {p_{w} q_{y}-p_{x} q_{z}+p_{y} q_{w}+p_{z} q_{x}} \ {p_{w} q_{z}+p_{x} q_{y}-p_{y} q_{x}+p_{z} q_{w}}\end{array}\right]
$$</p>
<p>An unit quaternion can always can be ï¼$q_{R}(\alpha, \mathbf{u})=\left[\cos \frac{\alpha}{2}, \sin \frac{\alpha}{2} \cdot \mathbf{u}\right]$</p>
<p>where $\alpha$ is rotation angleï¼$\mathbf{u} \in \mathbb{R}^{3}$ is rotation axisï¼and $\|\mathbf{u}\|=1$.</p>
<h3 id="conversion-between-quaternions-rotation-matrices-and-euler-angles">Conversion between quaternions, rotation matrices, and Euler angles</h3>
<h4 id="quaternion-rotation-matrix">Quaternion -&gt; Rotation matrix</h4>
<p>(Where quaternion is b-&gt;n,  R is n-&gt;b)</p>
<p>$$
R^{b}<em>{n} =\left[\begin{array}{ccc}{q</em>{0}^{2}+q_{1}^{2}-q_{2}^{2}-q_{3}^{2}} &amp; {2\left(q_{1} q_{2}+q_{0} q_{3}\right)} &amp; {2\left(q_{1} q_{3}-q_{0} q_{2}\right)} \ {2\left(q_{1} q_{2}-q_{0} q_{3}\right)} &amp; {q_{0}^{2}-q_{1}^{2}+q_{2}^{2}-q_{3}^{2}} &amp; {2\left(q_{2} q_{3}+q_{0} q_{1}\right)} \ {2\left(q_{1} q_{3}+q_{0} q_{2}\right)} &amp; {2\left(q_{2} q_{3}-q_{0} q_{1}\right)} &amp; {q_{0}^{2}-q_{1}^{2}-q_{2}^{2}+q_{3}^{2}}\end{array}\right]
$$</p>
<h4 id="quaternion-euler-angles">Quaternion -&gt; Euler angles</h4>
<p>Rotation matrix, quaternion and Euler angles are three common ways to represent rotation. However, the rotation order must be specified first before you converse <strong>quaternion to Euler angles</strong> and <strong>rotation matrix to Euler angles</strong>. This product uses the "ZYX" rotation sequence which rotates heading angle first, and then the pitch angle, and the last is roll angle.</p>
<p>Formula :</p>
<p>$$
\left[\begin{array}{c}{\phi}(Roll) \ {\theta}(Pitch) \ {\psi}(Heading)\end{array}\right] = \left[\begin{array}{c}{\operatorname{atan} 2\left(2 q_{2} q_{3}+2 q_{0} q_{1},  {q_{3}^{2}-q_{2}^{2}-q_{1}^{2}+q_{0}^{2} )}\right.} \ {-\operatorname{asin}\left(2 q_{1} q_{3}-2 q_{0} q_{2}\right)} \ {\operatorname{atan} 2\left(2 q_{1} q_{2}+2 q_{0} q_{3}\right)} , {q_{1}^{2}+q_{0}^{2}-q_{3}^{2}-q_{2}^{2} )}\end{array}\right]
$$</p>
<h4 id="euler-angles-quaternion">Euler angles -&gt; Quaternion</h4>
<p>From $s_{\phi}= \sin \frac{\phi}{2}, c_{\phi}= \cos \frac{\phi}{2}$, we gotï¼</p>
<p>$$
\mathbf{q}=\left[\begin{array}{c}{c_{\phi / 2} c_{\theta / 2} c_{\psi / 2}+s_{\phi / 2} s_{\theta / 2} s_{\psi / 2}} \ {-c_{\phi / 2} s_{\theta / 2} s_{\psi / 2}+c_{\theta / 2} c_{\psi / 2} s_{\phi / 2}} \ {c_{\phi / 2} c_{\psi / 2} s_{\theta / 2}+s_{\phi / 2} c_{\theta / 2} s_{\psi / 2}} \ {c_{\phi / 2} c_{\theta / 2} s_{\psi / 2}-s_{\phi / 2} c_{\psi / 2} s_{\theta / 2}}\end{array}\right]
$$</p>
<h4 id="euler-angles-rotation-matrix-n-b">Euler angles -&gt; Rotation matrix (n-&gt;b)</h4>
<p>$$
R^{b}<em>{n} = \left[\begin{array}{ccc}{c</em>{\theta} c_{\psi}} &amp; {c_{\theta} s_{\psi}} &amp; {-s_{\theta}} \ {s_{\phi} s_{\theta} c_{\psi}-c_{\phi} s_{\psi}} &amp; {s_{\phi} s_{\theta} s_{\psi}+c_{\phi} c_{\psi}} &amp; {c_{\theta} s_{\phi}} \ {c_{\phi} s_{\theta} c_{\psi}+s_{\phi} s_{\psi}} &amp; {c_{\phi} s_{\theta} s_{\psi}-s_{\phi} c_{\psi}} &amp; {c_{\theta} c_{\phi}}\end{array}\right]
$$</p>
<h4 id="rotation-matrix-n-b-euler-angles">Rotation matrix (n-&gt;b) -&gt; Euler angles</h4>
<p>$$
\left[\begin{array}{c}{\phi} \ {\theta} \ {\psi}\end{array}\right]=\left[\begin{array}{c}{\operatorname{atan} 2\left(r_{23}, r_{33}\right)} \ {-\operatorname{asin}\left(r_{13}\right)} \ {\operatorname{atan} 2\left(r_{12}, r_{11}\right)}\end{array}\right]
$$</p>
<h2 id="appendix-c-firmware-upgrade-and-factory-reset">Appendix C - Firmware Upgrade and Factory Reset</h2>
<p>This product supports online firmware upgrade. Please pay attention to the official website of Supercore Electronics www.hipnuc.com for the latest firmware.
Firmware upgrade steps:</p>
<ul>
<li>Get the latest firmware file. The extension of the file is (.hex).</li>
<li>Connect the module, and run "Uranus". Switch to the firmware upgrade window, and set Baud (Baudrate) to 115200. </li>
<li>Click "connect" button. If the module information shows successfully, meaning that the system is ready to upgrade. </li>
<li>Now you can click the file selector (), and select the firmware with the extension xxx.hex and click to start programming. After the download is completed, there will be a successful notification.</li>
<li>Close the serial port and restart the module. Now it's upgraded.</li>
</ul>
<p><img alt="" src="common_figures/firmware_update.png"></p></main>
<script>
    var tocElem = document.querySelector("aside.toc");
    tocElem.style.setProperty("height", window.innerHeight+'px');
    
    window.addEventListener("resize", resizeThrottler, false);
    
    var resizeTimeout;
    function resizeThrottler() {
    // ignore resize events as long as an actualResizeHandler execution is in the queue
    if ( !resizeTimeout ) {
        resizeTimeout = setTimeout(function() {
        resizeTimeout = null;
        actualResizeHandler();
       }, 300);
    }
  }
  
  function actualResizeHandler() {
    tocElem.style.setProperty("height", window.innerHeight+'px');
  }
</script>
<body>
