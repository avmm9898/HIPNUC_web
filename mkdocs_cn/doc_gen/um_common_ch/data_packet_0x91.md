## 数据包

#### 数据包总览

| 数据包标签 | 数据包长度(包含标签1字节) | 名称                | 备注 |
| ---------- | ------------------------- | ------------------- | ---- |
| 0x91       | 76                        | IMUSOL(IMU数据集合) |      |

#### 产品支持数据包列表

#### 0X91( IMUSOL)

共76字节。集成了IMU的传感器原始输出和姿态解算数据。

| 字节偏移 | 类型     | 大小 | 单位                 | 说明                                                         |
| -------- | -------- | ---- | -------------------- | ------------------------------------------------------------ |
| 0        | uint8_t  | 1    | -                    | 数据包标签:0x91                                              |
| 1        | uint8_t  | 1    | -                    | ID                                                           |
| 2        | -        | 6    | -                    | 保留                                                         |
| 8        | uint32_t | 4    | ms                   | 时间戳信息，从系统开机开始累加，每毫秒增加1                  |
| 12       | float    | 12   | 1G(1G = 1重力加速度) | 加速度,顺序为：XYZ(注意单位和0xA0包不同)                     |
| 24       | float    | 12   | deg/s                | 角速度,顺序为： XYZ(注意单位和0xB0包不同)                    |
| 36       | float    | 12   | uT                   | 磁强度,顺序为： XYZ(注意单位和0xC0包不同)                    |
| 48       | float    | 12   | deg                  | 节点欧拉角 顺序为：横滚角(Roll)，俯仰角(Pitch)，航向角(Yaw)(注意顺序和单位与0xD0包不同) |
| 60       | float    | 16   | -                    | 节点四元数集合,顺序为WXYZ                                    |

### 出厂默认数据包

出厂默认一帧中携带数据包数据定义如下：

| 产品  | 默认输出数据包 |
| ----- | -------------- |
| CH100 | 91             |
| CH110 | 91             |

### 数据帧结构示例

#### 数据帧配置为 `0x91` 数据包

使用串口助手采样一帧数据,共82字节, 前6字节为帧头, 长度和CRC校验值。剩余76字节为数据域。假设数据接收到C语言数组`buf`中。如下所示:

5A A5 4C 00 6C 51 **91** 00 A0 3B 01 A8 02 97 BD BB 04 00 9C A0 65 3E A2 26 45 3F 5C E7 30 3F E2 D4 5A C2 E5 9D A0 C1 EB 23 EE C2 78 77 99 41 AB AA D1 C1 AB 2A 0A C2 8D E1 42 42 8F 1D A8 C1 1E 0C 36 C2 E6 E5 5A 3F C1 94 9E 3E B8 C0 9E BE BE DF 8D BE

* 第一步：判断帧头，得到数据域长度和帧CRC：

帧头:`5A` `A5`

帧数据域长度:`4C` `00`: (0x00<<8) + 0x4C = 76

帧CRC校验值:`6C` `51`:(0x51<<8) + 0x6C = 0x516C

* 第二步： 校验CRC

```
    uint16_t payload_len;
    uint16_t crc;
    
    crc = 0;
    payload_len = buf[2] + (buf[3] << 8);
    
    /* calulate 5A A5 and LEN filed crc */
    crc16_update(&crc, buf, 4);
    
    /* calulate payload crc */
    crc16_update(&crc, buf + 6, payload_len);
```

得到CRC值为0x516C, 与帧中携带CRC值相同，帧CRC校验通过。

* 第三步：接收数据

从`0x91`开始为数据包的数据域。在C语言中可以定义结构体来方便的读取数据：

定义0x91数据包结构体如下：

```
__packed typedef struct
{
    uint8_t     tag;                /* 数据标签:0x91 */
    uint8_t     id;					/* 模块ID */
    uint8_t     rev[6];             /* reserved */
    uint32_t    ts;                 /* 时间戳 */
    float       acc[3];				/* 加速度 */
    float       gyr[3];				/* 角速度 */
    float       mag[3];				/* 地磁 */
    float       eul[3];             /* 欧拉角: Roll,Pitch,Yaw */
    float       quat[4];            /* 四元数 */
}id0x91_t;
```

`__packed` 为编译器关键字(Keil下)，表示结构体按字节紧对齐，结构体每一个元素一一对应0x91数据包的结构定义。接收数据时将接收到的数组直接memcpy到结构体即可：(注意定义结构体时必须4字节对齐), 其中`buf `指向帧头, `buf[6]`指向帧中数据域 。

```
    /* 接收数据并使用0x91数据包结构定义来解释数据 */
    __align(4) id0x91_t dat;    /* struct must be 4 byte aligned */
    memcpy(&dat, &buf[6], sizeof(id0x91_t));
```

最后得到dat数据结果：

```
id              : 0
timestamp       : 310205
acc             :    0.224    0.770    0.691
gyr             :  -54.708  -20.077 -119.070
mag             :   19.183  -26.208  -34.542
eul(R/P/Y)      :   48.720  -21.014  -45.512
quat            :    0.855    0.310   -0.310   -0.277
```

